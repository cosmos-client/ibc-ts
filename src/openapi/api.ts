/* tslint:disable */
/* eslint-disable */
/**
 * IBC-GO - gRPC Gateway docs
 * A REST interface for state queries
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method. Besides the Channel end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface Channel200Response
 */
export interface Channel200Response {
    /**
     * 
     * @type {ChannelAssociatedWithTheRequestIdentifiers}
     * @memberof Channel200Response
     */
    'channel'?: ChannelAssociatedWithTheRequestIdentifiers;
    /**
     * 
     * @type {string}
     * @memberof Channel200Response
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof Channel200Response
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @export
 * @interface ChannelAssociatedWithTheRequestIdentifiers
 */
export interface ChannelAssociatedWithTheRequestIdentifiers {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    'state'?: ChannelAssociatedWithTheRequestIdentifiersStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    'ordering'?: ChannelAssociatedWithTheRequestIdentifiersOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    'counterparty'?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    'connection_hops'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    'version'?: string;
}

export const ChannelAssociatedWithTheRequestIdentifiersStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN',
    Closed: 'STATE_CLOSED'
} as const;

export type ChannelAssociatedWithTheRequestIdentifiersStateEnum = typeof ChannelAssociatedWithTheRequestIdentifiersStateEnum[keyof typeof ChannelAssociatedWithTheRequestIdentifiersStateEnum];
export const ChannelAssociatedWithTheRequestIdentifiersOrderingEnum = {
    NoneUnspecified: 'ORDER_NONE_UNSPECIFIED',
    Unordered: 'ORDER_UNORDERED',
    Ordered: 'ORDER_ORDERED'
} as const;

export type ChannelAssociatedWithTheRequestIdentifiersOrderingEnum = typeof ChannelAssociatedWithTheRequestIdentifiersOrderingEnum[keyof typeof ChannelAssociatedWithTheRequestIdentifiersOrderingEnum];

/**
 * QueryChannelsResponse is the response type for the Query/Channels RPC method.
 * @export
 * @interface Channels200Response
 */
export interface Channels200Response {
    /**
     * list of stored channels of the chain.
     * @type {Array<Channels200ResponseChannelsInner>}
     * @memberof Channels200Response
     */
    'channels'?: Array<Channels200ResponseChannelsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof Channels200Response
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof Channels200Response
     */
    'height'?: QueryBlockHeight;
}
/**
 * IdentifiedChannel defines a channel with additional port and channel identifier fields.
 * @export
 * @interface Channels200ResponseChannelsInner
 */
export interface Channels200ResponseChannelsInner {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof Channels200ResponseChannelsInner
     */
    'state'?: Channels200ResponseChannelsInnerStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof Channels200ResponseChannelsInner
     */
    'ordering'?: Channels200ResponseChannelsInnerOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof Channels200ResponseChannelsInner
     */
    'counterparty'?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof Channels200ResponseChannelsInner
     */
    'connection_hops'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Channels200ResponseChannelsInner
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channels200ResponseChannelsInner
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channels200ResponseChannelsInner
     */
    'channel_id'?: string;
}

export const Channels200ResponseChannelsInnerStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN',
    Closed: 'STATE_CLOSED'
} as const;

export type Channels200ResponseChannelsInnerStateEnum = typeof Channels200ResponseChannelsInnerStateEnum[keyof typeof Channels200ResponseChannelsInnerStateEnum];
export const Channels200ResponseChannelsInnerOrderingEnum = {
    NoneUnspecified: 'ORDER_NONE_UNSPECIFIED',
    Unordered: 'ORDER_UNORDERED',
    Ordered: 'ORDER_ORDERED'
} as const;

export type Channels200ResponseChannelsInnerOrderingEnum = typeof Channels200ResponseChannelsInnerOrderingEnum[keyof typeof Channels200ResponseChannelsInnerOrderingEnum];

/**
 * QueryClientParamsResponse is the response type for the Query/ClientParams RPC method.
 * @export
 * @interface ClientParams200Response
 */
export interface ClientParams200Response {
    /**
     * 
     * @type {ClientParams200ResponseParams}
     * @memberof ClientParams200Response
     */
    'params'?: ClientParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface ClientParams200ResponseParams
 */
export interface ClientParams200ResponseParams {
    /**
     * allowed_clients defines the list of allowed client state types.
     * @type {Array<string>}
     * @memberof ClientParams200ResponseParams
     */
    'allowed_clients'?: Array<string>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ClientState
 */
export interface ClientState {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ClientState
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ClientState
     */
    'value'?: string;
}
/**
 * QueryClientStateResponse is the response type for the Query/ClientState RPC method. Besides the client state, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface ClientState200Response
 */
export interface ClientState200Response {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof ClientState200Response
     */
    'client_state'?: ClientStateAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof ClientState200Response
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof ClientState200Response
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface ClientStateAssociatedWithTheChannel
 */
export interface ClientStateAssociatedWithTheChannel {
    /**
     * 
     * @type {string}
     * @memberof ClientStateAssociatedWithTheChannel
     */
    'client_id'?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof ClientStateAssociatedWithTheChannel
     */
    'client_state'?: ClientState;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ClientStateAssociatedWithTheRequestIdentifier
 */
export interface ClientStateAssociatedWithTheRequestIdentifier {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ClientStateAssociatedWithTheRequestIdentifier
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ClientStateAssociatedWithTheRequestIdentifier
     */
    'value'?: string;
}
/**
 * QueryClientStatesResponse is the response type for the Query/ClientStates RPC method.
 * @export
 * @interface ClientStates200Response
 */
export interface ClientStates200Response {
    /**
     * list of stored ClientStates of the chain.
     * @type {Array<ClientStates200ResponseClientStatesInner>}
     * @memberof ClientStates200Response
     */
    'client_states'?: Array<ClientStates200ResponseClientStatesInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof ClientStates200Response
     */
    'pagination'?: PaginationResponse;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface ClientStates200ResponseClientStatesInner
 */
export interface ClientStates200ResponseClientStatesInner {
    /**
     * 
     * @type {string}
     * @memberof ClientStates200ResponseClientStatesInner
     */
    'client_id'?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof ClientStates200ResponseClientStatesInner
     */
    'client_state'?: ClientState;
}
/**
 * QueryClientStatusResponse is the response type for the Query/ClientStatus RPC method. It returns the current status of the IBC client.
 * @export
 * @interface ClientStatus200Response
 */
export interface ClientStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof ClientStatus200Response
     */
    'status'?: string;
}
/**
 * QueryConnectionResponse is the response type for the Query/Connection RPC method. Besides the connection end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface Connection200Response
 */
export interface Connection200Response {
    /**
     * 
     * @type {ConnectionAssociatedWithTheRequestIdentifier}
     * @memberof Connection200Response
     */
    'connection'?: ConnectionAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof Connection200Response
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof Connection200Response
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * ConnectionEnd defines a stateful object on a chain connected to another separate one. NOTE: there must only be 2 defined ConnectionEnds to establish a connection between two chains.
 * @export
 * @interface ConnectionAssociatedWithTheRequestIdentifier
 */
export interface ConnectionAssociatedWithTheRequestIdentifier {
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    'client_id'?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for channels or packets utilising this connection.
     * @type {Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    'versions'?: Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    'state'?: ConnectionAssociatedWithTheRequestIdentifierStateEnum;
    /**
     * 
     * @type {Connections200ResponseConnectionsInnerCounterparty}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    'counterparty'?: Connections200ResponseConnectionsInnerCounterparty;
    /**
     * delay period that must pass before a consensus state can be used for packet-verification NOTE: delay period logic is only implemented by some clients.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    'delay_period'?: string;
}

export const ConnectionAssociatedWithTheRequestIdentifierStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN'
} as const;

export type ConnectionAssociatedWithTheRequestIdentifierStateEnum = typeof ConnectionAssociatedWithTheRequestIdentifierStateEnum[keyof typeof ConnectionAssociatedWithTheRequestIdentifierStateEnum];

/**
 * QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.
 * @export
 * @interface ConnectionParams200Response
 */
export interface ConnectionParams200Response {
    /**
     * 
     * @type {ConnectionParams200ResponseParams}
     * @memberof ConnectionParams200Response
     */
    'params'?: ConnectionParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface ConnectionParams200ResponseParams
 */
export interface ConnectionParams200ResponseParams {
    /**
     * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the largest amount of time that the chain might reasonably take to produce the next block under normal operating conditions. A safe choice is 3-5x the expected time per block.
     * @type {string}
     * @memberof ConnectionParams200ResponseParams
     */
    'max_expected_time_per_block'?: string;
}
/**
 * QueryConnectionsResponse is the response type for the Query/Connections RPC method.
 * @export
 * @interface Connections200Response
 */
export interface Connections200Response {
    /**
     * list of stored connections of the chain.
     * @type {Array<Connections200ResponseConnectionsInner>}
     * @memberof Connections200Response
     */
    'connections'?: Array<Connections200ResponseConnectionsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof Connections200Response
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof Connections200Response
     */
    'height'?: QueryBlockHeight;
}
/**
 * IdentifiedConnection defines a connection with additional connection identifier field.
 * @export
 * @interface Connections200ResponseConnectionsInner
 */
export interface Connections200ResponseConnectionsInner {
    /**
     * connection identifier.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInner
     */
    'id'?: string;
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInner
     */
    'client_id'?: string;
    /**
     * 
     * @type {Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>}
     * @memberof Connections200ResponseConnectionsInner
     */
    'versions'?: Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInner
     */
    'state'?: Connections200ResponseConnectionsInnerStateEnum;
    /**
     * 
     * @type {Connections200ResponseConnectionsInnerCounterparty}
     * @memberof Connections200ResponseConnectionsInner
     */
    'counterparty'?: Connections200ResponseConnectionsInnerCounterparty;
    /**
     * delay period associated with this connection.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInner
     */
    'delay_period'?: string;
}

export const Connections200ResponseConnectionsInnerStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN'
} as const;

export type Connections200ResponseConnectionsInnerStateEnum = typeof Connections200ResponseConnectionsInnerStateEnum[keyof typeof Connections200ResponseConnectionsInnerStateEnum];

/**
 * counterparty chain associated with this connection.
 * @export
 * @interface Connections200ResponseConnectionsInnerCounterparty
 */
export interface Connections200ResponseConnectionsInnerCounterparty {
    /**
     * identifies the client on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInnerCounterparty
     */
    'client_id'?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof Connections200ResponseConnectionsInnerCounterparty
     */
    'connection_id'?: string;
    /**
     * 
     * @type {MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey}
     * @memberof Connections200ResponseConnectionsInnerCounterparty
     */
    'prefix'?: MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusState
 */
export interface ConsensusState {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusState
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusState
     */
    'value'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusStateAssociatedWithTheChannel
 */
export interface ConsensusStateAssociatedWithTheChannel {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheChannel
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheChannel
     */
    'value'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
 */
export interface ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
     */
    'value'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusStateAssociatedWithTheRequestIdentifier
 */
export interface ConsensusStateAssociatedWithTheRequestIdentifier {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheRequestIdentifier
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheRequestIdentifier
     */
    'value'?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface ConsensusStateHeight
 */
export interface ConsensusStateHeight {
    /**
     * 
     * @type {string}
     * @memberof ConsensusStateHeight
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsensusStateHeight
     */
    'revision_height'?: string;
}
/**
 * ConsensusStateWithHeight defines a consensus state with an additional height field.
 * @export
 * @interface ConsensusStatesAssociatedWithTheIdentifierInner
 */
export interface ConsensusStatesAssociatedWithTheIdentifierInner {
    /**
     * 
     * @type {ConsensusStateHeight}
     * @memberof ConsensusStatesAssociatedWithTheIdentifierInner
     */
    'height'?: ConsensusStateHeight;
    /**
     * 
     * @type {ConsensusState}
     * @memberof ConsensusStatesAssociatedWithTheIdentifierInner
     */
    'consensus_state'?: ConsensusState;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'key'?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'offset'?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'limit'?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'count_total'?: boolean;
    /**
     * reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'reverse'?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'total'?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface CounterpartyChannelEnd
 */
export interface CounterpartyChannelEnd {
    /**
     * port on the counterparty chain which owns the other end of the channel.
     * @type {string}
     * @memberof CounterpartyChannelEnd
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyChannelEnd
     */
    'channel_id'?: string;
}
/**
 * QueryDenomHashResponse is the response type for the Query/DenomHash RPC method.
 * @export
 * @interface DenomHash200Response
 */
export interface DenomHash200Response {
    /**
     * hash (in hex format) of the denomination trace information.
     * @type {string}
     * @memberof DenomHash200Response
     */
    'hash'?: string;
}
/**
 * QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method.
 * @export
 * @interface DenomTrace200Response
 */
export interface DenomTrace200Response {
    /**
     * 
     * @type {DenomTraces200ResponseDenomTracesInner}
     * @memberof DenomTrace200Response
     */
    'denom_trace'?: DenomTraces200ResponseDenomTracesInner;
}
/**
 * QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method.
 * @export
 * @interface DenomTraces200Response
 */
export interface DenomTraces200Response {
    /**
     * denom_traces returns all denominations trace information.
     * @type {Array<DenomTraces200ResponseDenomTracesInner>}
     * @memberof DenomTraces200Response
     */
    'denom_traces'?: Array<DenomTraces200ResponseDenomTracesInner>;
    /**
     * 
     * @type {DenomTraces200ResponsePagination}
     * @memberof DenomTraces200Response
     */
    'pagination'?: DenomTraces200ResponsePagination;
}
/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing information path.
 * @export
 * @interface DenomTraces200ResponseDenomTracesInner
 */
export interface DenomTraces200ResponseDenomTracesInner {
    /**
     * path defines the chain of port/channel identifiers used for tracing the source of the fungible token.
     * @type {string}
     * @memberof DenomTraces200ResponseDenomTracesInner
     */
    'path'?: string;
    /**
     * base denomination of the relayed fungible token.
     * @type {string}
     * @memberof DenomTraces200ResponseDenomTracesInner
     */
    'base_denom'?: string;
}
/**
 * pagination defines the pagination in the response.
 * @export
 * @interface DenomTraces200ResponsePagination
 */
export interface DenomTraces200ResponsePagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof DenomTraces200ResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DenomTraces200ResponsePagination
     */
    'total'?: string;
}
/**
 * QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.
 * @export
 * @interface EscrowAddress200Response
 */
export interface EscrowAddress200Response {
    /**
     * 
     * @type {string}
     * @memberof EscrowAddress200Response
     */
    'escrow_address'?: string;
}
/**
 * 
 * @export
 * @interface EscrowAddressDefaultResponse
 */
export interface EscrowAddressDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof EscrowAddressDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof EscrowAddressDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof EscrowAddressDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<EscrowAddressDefaultResponseDetailsInner>}
     * @memberof EscrowAddressDefaultResponse
     */
    'details'?: Array<EscrowAddressDefaultResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface EscrowAddressDefaultResponseDetailsInner
 */
export interface EscrowAddressDefaultResponseDetailsInner {
    /**
     * 
     * @type {string}
     * @memberof EscrowAddressDefaultResponseDetailsInner
     */
    'type_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof EscrowAddressDefaultResponseDetailsInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel
 */
export interface FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel {
    /**
     * 
     * @type {string}
     * @memberof FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface FeeEnabledChannelDefaultResponse
 */
export interface FeeEnabledChannelDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof FeeEnabledChannelDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof FeeEnabledChannelDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeeEnabledChannelDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<FeeEnabledChannelDefaultResponseDetailsInner>}
     * @memberof FeeEnabledChannelDefaultResponse
     */
    'details'?: Array<FeeEnabledChannelDefaultResponseDetailsInner>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface FeeEnabledChannelDefaultResponseDetailsInner
 */
export interface FeeEnabledChannelDefaultResponseDetailsInner {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof FeeEnabledChannelDefaultResponseDetailsInner
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof FeeEnabledChannelDefaultResponseDetailsInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket
 */
export interface FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket
     */
    'recv_fee'?: Array<ThePacketReceiveFeeInner>;
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket
     */
    'ack_fee'?: Array<ThePacketReceiveFeeInner>;
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket
     */
    'timeout_fee'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'message'?: string;
    /**
     * 
     * @type {Array<FeeEnabledChannelDefaultResponseDetailsInner>}
     * @memberof GrpcGatewayRuntimeError
     */
    'details'?: Array<FeeEnabledChannelDefaultResponseDetailsInner>;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface HeightAtWhichTheProofWasGenerated
 */
export interface HeightAtWhichTheProofWasGenerated {
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasGenerated
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasGenerated
     */
    'revision_height'?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface HeightAtWhichTheProofWasRetrieved
 */
export interface HeightAtWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasRetrieved
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasRetrieved
     */
    'revision_height'?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients
 */
export interface HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients {
    /**
     * 
     * @type {string}
     * @memberof HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients
     */
    'revision_height'?: string;
}
/**
 * Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.
 * @export
 * @interface IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner
 */
export interface IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner {
    /**
     * 
     * @type {string}
     * @memberof IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner
     */
    'identifier'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner
     */
    'features'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1Fee
 */
export interface IbcApplicationsFeeV1Fee {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1Fee
     */
    'recv_fee'?: Array<ThePacketReceiveFeeInner>;
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1Fee
     */
    'ack_fee'?: Array<ThePacketReceiveFeeInner>;
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1Fee
     */
    'timeout_fee'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1FeeEnabledChannel
 */
export interface IbcApplicationsFeeV1FeeEnabledChannel {
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsFeeV1FeeEnabledChannel
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsFeeV1FeeEnabledChannel
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1IdentifiedPacketFees
 */
export interface IbcApplicationsFeeV1IdentifiedPacketFees {
    /**
     * 
     * @type {UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence}
     * @memberof IbcApplicationsFeeV1IdentifiedPacketFees
     */
    'packet_id'?: UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence;
    /**
     * 
     * @type {Array<PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers>}
     * @memberof IbcApplicationsFeeV1IdentifiedPacketFees
     */
    'packet_fees'?: Array<PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1PacketFee
 */
export interface IbcApplicationsFeeV1PacketFee {
    /**
     * 
     * @type {FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket}
     * @memberof IbcApplicationsFeeV1PacketFee
     */
    'fee'?: FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket;
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsFeeV1PacketFee
     */
    'refund_address'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcApplicationsFeeV1PacketFee
     */
    'relayers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryCounterpartyPayeeResponse
 */
export interface IbcApplicationsFeeV1QueryCounterpartyPayeeResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsFeeV1QueryCounterpartyPayeeResponse
     */
    'counterparty_payee'?: string;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryFeeEnabledChannelResponse
 */
export interface IbcApplicationsFeeV1QueryFeeEnabledChannelResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IbcApplicationsFeeV1QueryFeeEnabledChannelResponse
     */
    'fee_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryFeeEnabledChannelsResponse
 */
export interface IbcApplicationsFeeV1QueryFeeEnabledChannelsResponse {
    /**
     * 
     * @type {Array<FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel>}
     * @memberof IbcApplicationsFeeV1QueryFeeEnabledChannelsResponse
     */
    'fee_enabled_channels'?: Array<FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryIncentivizedPacketResponse
 */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketResponse {
    /**
     * 
     * @type {IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId}
     * @memberof IbcApplicationsFeeV1QueryIncentivizedPacketResponse
     */
    'incentivized_packet'?: IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryIncentivizedPacketsForChannelResponse
 */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketsForChannelResponse {
    /**
     * 
     * @type {Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>}
     * @memberof IbcApplicationsFeeV1QueryIncentivizedPacketsForChannelResponse
     */
    'incentivized_packets'?: Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryIncentivizedPacketsResponse
 */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketsResponse {
    /**
     * 
     * @type {Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>}
     * @memberof IbcApplicationsFeeV1QueryIncentivizedPacketsResponse
     */
    'incentivized_packets'?: Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryPayeeResponse
 */
export interface IbcApplicationsFeeV1QueryPayeeResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsFeeV1QueryPayeeResponse
     */
    'payee_address'?: string;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryTotalAckFeesResponse
 */
export interface IbcApplicationsFeeV1QueryTotalAckFeesResponse {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1QueryTotalAckFeesResponse
     */
    'ack_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryTotalRecvFeesResponse
 */
export interface IbcApplicationsFeeV1QueryTotalRecvFeesResponse {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1QueryTotalRecvFeesResponse
     */
    'recv_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface IbcApplicationsFeeV1QueryTotalTimeoutFeesResponse
 */
export interface IbcApplicationsFeeV1QueryTotalTimeoutFeesResponse {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof IbcApplicationsFeeV1QueryTotalTimeoutFeesResponse
     */
    'timeout_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * Params defines the set of on-chain interchain accounts parameters. The following parameters may be used to disable the controller submodule.
 * @export
 * @interface IbcApplicationsInterchainAccountsControllerV1Params
 */
export interface IbcApplicationsInterchainAccountsControllerV1Params {
    /**
     * controller_enabled enables or disables the controller submodule.
     * @type {boolean}
     * @memberof IbcApplicationsInterchainAccountsControllerV1Params
     */
    'controller_enabled'?: boolean;
}
/**
 * QueryInterchainAccountResponse the response type for the Query/InterchainAccount RPC method.
 * @export
 * @interface IbcApplicationsInterchainAccountsControllerV1QueryInterchainAccountResponse
 */
export interface IbcApplicationsInterchainAccountsControllerV1QueryInterchainAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsInterchainAccountsControllerV1QueryInterchainAccountResponse
     */
    'address'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface IbcApplicationsInterchainAccountsControllerV1QueryParamsResponse
 */
export interface IbcApplicationsInterchainAccountsControllerV1QueryParamsResponse {
    /**
     * 
     * @type {InterchainAccountsControllerParams200ResponseParams}
     * @memberof IbcApplicationsInterchainAccountsControllerV1QueryParamsResponse
     */
    'params'?: InterchainAccountsControllerParams200ResponseParams;
}
/**
 * Params defines the set of on-chain interchain accounts parameters. The following parameters may be used to disable the host submodule.
 * @export
 * @interface IbcApplicationsInterchainAccountsHostV1Params
 */
export interface IbcApplicationsInterchainAccountsHostV1Params {
    /**
     * host_enabled enables or disables the host submodule.
     * @type {boolean}
     * @memberof IbcApplicationsInterchainAccountsHostV1Params
     */
    'host_enabled'?: boolean;
    /**
     * allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain.
     * @type {Array<string>}
     * @memberof IbcApplicationsInterchainAccountsHostV1Params
     */
    'allow_messages'?: Array<string>;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface IbcApplicationsInterchainAccountsHostV1QueryParamsResponse
 */
export interface IbcApplicationsInterchainAccountsHostV1QueryParamsResponse {
    /**
     * 
     * @type {InterchainAccountsHostParams200ResponseParams}
     * @memberof IbcApplicationsInterchainAccountsHostV1QueryParamsResponse
     */
    'params'?: InterchainAccountsHostParams200ResponseParams;
}
/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing information path.
 * @export
 * @interface IbcApplicationsTransferV1DenomTrace
 */
export interface IbcApplicationsTransferV1DenomTrace {
    /**
     * path defines the chain of port/channel identifiers used for tracing the source of the fungible token.
     * @type {string}
     * @memberof IbcApplicationsTransferV1DenomTrace
     */
    'path'?: string;
    /**
     * base denomination of the relayed fungible token.
     * @type {string}
     * @memberof IbcApplicationsTransferV1DenomTrace
     */
    'base_denom'?: string;
}
/**
 * Params defines the set of IBC transfer parameters. NOTE: To prevent a single token from being transferred, set the TransfersEnabled parameter to true and then set the bank module\'s SendEnabled parameter for the denomination to false.
 * @export
 * @interface IbcApplicationsTransferV1Params
 */
export interface IbcApplicationsTransferV1Params {
    /**
     * send_enabled enables or disables all cross-chain token transfers from this chain.
     * @type {boolean}
     * @memberof IbcApplicationsTransferV1Params
     */
    'send_enabled'?: boolean;
    /**
     * receive_enabled enables or disables all cross-chain token transfers to this chain.
     * @type {boolean}
     * @memberof IbcApplicationsTransferV1Params
     */
    'receive_enabled'?: boolean;
}
/**
 * QueryDenomHashResponse is the response type for the Query/DenomHash RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryDenomHashResponse
 */
export interface IbcApplicationsTransferV1QueryDenomHashResponse {
    /**
     * hash (in hex format) of the denomination trace information.
     * @type {string}
     * @memberof IbcApplicationsTransferV1QueryDenomHashResponse
     */
    'hash'?: string;
}
/**
 * QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryDenomTraceResponse
 */
export interface IbcApplicationsTransferV1QueryDenomTraceResponse {
    /**
     * 
     * @type {DenomTraces200ResponseDenomTracesInner}
     * @memberof IbcApplicationsTransferV1QueryDenomTraceResponse
     */
    'denom_trace'?: DenomTraces200ResponseDenomTracesInner;
}
/**
 * QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryDenomTracesResponse
 */
export interface IbcApplicationsTransferV1QueryDenomTracesResponse {
    /**
     * denom_traces returns all denominations trace information.
     * @type {Array<DenomTraces200ResponseDenomTracesInner>}
     * @memberof IbcApplicationsTransferV1QueryDenomTracesResponse
     */
    'denom_traces'?: Array<DenomTraces200ResponseDenomTracesInner>;
    /**
     * 
     * @type {DenomTraces200ResponsePagination}
     * @memberof IbcApplicationsTransferV1QueryDenomTracesResponse
     */
    'pagination'?: DenomTraces200ResponsePagination;
}
/**
 * QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryEscrowAddressResponse
 */
export interface IbcApplicationsTransferV1QueryEscrowAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcApplicationsTransferV1QueryEscrowAddressResponse
     */
    'escrow_address'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryParamsResponse
 */
export interface IbcApplicationsTransferV1QueryParamsResponse {
    /**
     * 
     * @type {TransferParams200ResponseParams}
     * @memberof IbcApplicationsTransferV1QueryParamsResponse
     */
    'params'?: TransferParams200ResponseParams;
}
/**
 * Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @export
 * @interface IbcCoreChannelV1Channel
 */
export interface IbcCoreChannelV1Channel {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    'state'?: IbcCoreChannelV1ChannelStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    'ordering'?: IbcCoreChannelV1ChannelOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof IbcCoreChannelV1Channel
     */
    'counterparty'?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1Channel
     */
    'connection_hops'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    'version'?: string;
}

export const IbcCoreChannelV1ChannelStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN',
    Closed: 'STATE_CLOSED'
} as const;

export type IbcCoreChannelV1ChannelStateEnum = typeof IbcCoreChannelV1ChannelStateEnum[keyof typeof IbcCoreChannelV1ChannelStateEnum];
export const IbcCoreChannelV1ChannelOrderingEnum = {
    NoneUnspecified: 'ORDER_NONE_UNSPECIFIED',
    Unordered: 'ORDER_UNORDERED',
    Ordered: 'ORDER_ORDERED'
} as const;

export type IbcCoreChannelV1ChannelOrderingEnum = typeof IbcCoreChannelV1ChannelOrderingEnum[keyof typeof IbcCoreChannelV1ChannelOrderingEnum];

/**
 * 
 * @export
 * @interface IbcCoreChannelV1Counterparty
 */
export interface IbcCoreChannelV1Counterparty {
    /**
     * port on the counterparty chain which owns the other end of the channel.
     * @type {string}
     * @memberof IbcCoreChannelV1Counterparty
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1Counterparty
     */
    'channel_id'?: string;
}
/**
 * IdentifiedChannel defines a channel with additional port and channel identifier fields.
 * @export
 * @interface IbcCoreChannelV1IdentifiedChannel
 */
export interface IbcCoreChannelV1IdentifiedChannel {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'state'?: IbcCoreChannelV1IdentifiedChannelStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'ordering'?: IbcCoreChannelV1IdentifiedChannelOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'counterparty'?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'connection_hops'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    'channel_id'?: string;
}

export const IbcCoreChannelV1IdentifiedChannelStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN',
    Closed: 'STATE_CLOSED'
} as const;

export type IbcCoreChannelV1IdentifiedChannelStateEnum = typeof IbcCoreChannelV1IdentifiedChannelStateEnum[keyof typeof IbcCoreChannelV1IdentifiedChannelStateEnum];
export const IbcCoreChannelV1IdentifiedChannelOrderingEnum = {
    NoneUnspecified: 'ORDER_NONE_UNSPECIFIED',
    Unordered: 'ORDER_UNORDERED',
    Ordered: 'ORDER_ORDERED'
} as const;

export type IbcCoreChannelV1IdentifiedChannelOrderingEnum = typeof IbcCoreChannelV1IdentifiedChannelOrderingEnum[keyof typeof IbcCoreChannelV1IdentifiedChannelOrderingEnum];

/**
 * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
 * @export
 * @enum {string}
 */

export const IbcCoreChannelV1Order = {
    NoneUnspecified: 'ORDER_NONE_UNSPECIFIED',
    Unordered: 'ORDER_UNORDERED',
    Ordered: 'ORDER_ORDERED'
} as const;

export type IbcCoreChannelV1Order = typeof IbcCoreChannelV1Order[keyof typeof IbcCoreChannelV1Order];


/**
 * 
 * @export
 * @interface IbcCoreChannelV1PacketId
 */
export interface IbcCoreChannelV1PacketId {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1PacketId
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1PacketId
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1PacketId
     */
    'sequence'?: string;
}
/**
 * PacketState defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @export
 * @interface IbcCoreChannelV1PacketState
 */
export interface IbcCoreChannelV1PacketState {
    /**
     * channel port identifier.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    'port_id'?: string;
    /**
     * channel unique identifier.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    'channel_id'?: string;
    /**
     * packet sequence.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    'sequence'?: string;
    /**
     * embedded data that represents packet state.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryChannelClientStateResponse
 */
export interface IbcCoreChannelV1QueryChannelClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    'identified_client_state'?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryChannelConsensusStateResponse
 */
export interface IbcCoreChannelV1QueryChannelConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method. Besides the Channel end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreChannelV1QueryChannelResponse
 */
export interface IbcCoreChannelV1QueryChannelResponse {
    /**
     * 
     * @type {ChannelAssociatedWithTheRequestIdentifiers}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    'channel'?: ChannelAssociatedWithTheRequestIdentifiers;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryChannelsResponse is the response type for the Query/Channels RPC method.
 * @export
 * @interface IbcCoreChannelV1QueryChannelsResponse
 */
export interface IbcCoreChannelV1QueryChannelsResponse {
    /**
     * list of stored channels of the chain.
     * @type {Array<Channels200ResponseChannelsInner>}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    'channels'?: Array<Channels200ResponseChannelsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryConnectionChannelsResponse
 */
export interface IbcCoreChannelV1QueryConnectionChannelsResponse {
    /**
     * list of channels associated with a connection.
     * @type {Array<Channels200ResponseChannelsInner>}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    'channels'?: Array<Channels200ResponseChannelsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryNextSequenceReceiveResponse
 */
export interface IbcCoreChannelV1QueryNextSequenceReceiveResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    'next_sequence_receive'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketAcknowledgementResponse
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    'acknowledgement'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketAcknowledgementsResponse
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementsResponse {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    'acknowledgements'?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketCommitmentResponse
 */
export interface IbcCoreChannelV1QueryPacketCommitmentResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    'commitment'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketCommitmentsResponse
 */
export interface IbcCoreChannelV1QueryPacketCommitmentsResponse {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    'commitments'?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketReceiptResponse
 */
export interface IbcCoreChannelV1QueryPacketReceiptResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    'received'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryUnreceivedAcksResponse
 */
export interface IbcCoreChannelV1QueryUnreceivedAcksResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1QueryUnreceivedAcksResponse
     */
    'sequences'?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryUnreceivedAcksResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryUnreceivedPacketsResponse
 */
export interface IbcCoreChannelV1QueryUnreceivedPacketsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1QueryUnreceivedPacketsResponse
     */
    'sequences'?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryUnreceivedPacketsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
 * @export
 * @enum {string}
 */

export const IbcCoreChannelV1State = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN',
    Closed: 'STATE_CLOSED'
} as const;

export type IbcCoreChannelV1State = typeof IbcCoreChannelV1State[keyof typeof IbcCoreChannelV1State];


/**
 * ConsensusStateWithHeight defines a consensus state with an additional height field.
 * @export
 * @interface IbcCoreClientV1ConsensusStateWithHeight
 */
export interface IbcCoreClientV1ConsensusStateWithHeight {
    /**
     * 
     * @type {ConsensusStateHeight}
     * @memberof IbcCoreClientV1ConsensusStateWithHeight
     */
    'height'?: ConsensusStateHeight;
    /**
     * 
     * @type {ConsensusState}
     * @memberof IbcCoreClientV1ConsensusStateWithHeight
     */
    'consensus_state'?: ConsensusState;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface IbcCoreClientV1Height
 */
export interface IbcCoreClientV1Height {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1Height
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1Height
     */
    'revision_height'?: string;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface IbcCoreClientV1IdentifiedClientState
 */
export interface IbcCoreClientV1IdentifiedClientState {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1IdentifiedClientState
     */
    'client_id'?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof IbcCoreClientV1IdentifiedClientState
     */
    'client_state'?: ClientState;
}
/**
 * Params defines the set of IBC light client parameters.
 * @export
 * @interface IbcCoreClientV1Params
 */
export interface IbcCoreClientV1Params {
    /**
     * allowed_clients defines the list of allowed client state types.
     * @type {Array<string>}
     * @memberof IbcCoreClientV1Params
     */
    'allowed_clients'?: Array<string>;
}
/**
 * QueryClientParamsResponse is the response type for the Query/ClientParams RPC method.
 * @export
 * @interface IbcCoreClientV1QueryClientParamsResponse
 */
export interface IbcCoreClientV1QueryClientParamsResponse {
    /**
     * 
     * @type {ClientParams200ResponseParams}
     * @memberof IbcCoreClientV1QueryClientParamsResponse
     */
    'params'?: ClientParams200ResponseParams;
}
/**
 * QueryClientStateResponse is the response type for the Query/ClientState RPC method. Besides the client state, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreClientV1QueryClientStateResponse
 */
export interface IbcCoreClientV1QueryClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    'client_state'?: ClientStateAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryClientStatesResponse is the response type for the Query/ClientStates RPC method.
 * @export
 * @interface IbcCoreClientV1QueryClientStatesResponse
 */
export interface IbcCoreClientV1QueryClientStatesResponse {
    /**
     * list of stored ClientStates of the chain.
     * @type {Array<ClientStates200ResponseClientStatesInner>}
     * @memberof IbcCoreClientV1QueryClientStatesResponse
     */
    'client_states'?: Array<ClientStates200ResponseClientStatesInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreClientV1QueryClientStatesResponse
     */
    'pagination'?: PaginationResponse;
}
/**
 * QueryClientStatusResponse is the response type for the Query/ClientStatus RPC method. It returns the current status of the IBC client.
 * @export
 * @interface IbcCoreClientV1QueryClientStatusResponse
 */
export interface IbcCoreClientV1QueryClientStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1QueryClientStatusResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface IbcCoreClientV1QueryConsensusStateHeightsResponse
 */
export interface IbcCoreClientV1QueryConsensusStateHeightsResponse {
    /**
     * 
     * @type {Array<HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients>}
     * @memberof IbcCoreClientV1QueryConsensusStateHeightsResponse
     */
    'consensus_state_heights'?: Array<HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreClientV1QueryConsensusStateHeightsResponse
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface IbcCoreClientV1QueryConsensusStateResponse
 */
export interface IbcCoreClientV1QueryConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    'proof_height'?: HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients;
}
/**
 * 
 * @export
 * @interface IbcCoreClientV1QueryConsensusStatesResponse
 */
export interface IbcCoreClientV1QueryConsensusStatesResponse {
    /**
     * 
     * @type {Array<ConsensusStatesAssociatedWithTheIdentifierInner>}
     * @memberof IbcCoreClientV1QueryConsensusStatesResponse
     */
    'consensus_states'?: Array<ConsensusStatesAssociatedWithTheIdentifierInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreClientV1QueryConsensusStatesResponse
     */
    'pagination'?: PaginationResponse;
}
/**
 * QueryUpgradedClientStateResponse is the response type for the Query/UpgradedClientState RPC method.
 * @export
 * @interface IbcCoreClientV1QueryUpgradedClientStateResponse
 */
export interface IbcCoreClientV1QueryUpgradedClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreClientV1QueryUpgradedClientStateResponse
     */
    'upgraded_client_state'?: ClientStateAssociatedWithTheRequestIdentifier;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface IbcCoreClientV1QueryUpgradedConsensusStateResponse
 */
export interface IbcCoreClientV1QueryUpgradedConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreClientV1QueryUpgradedConsensusStateResponse
     */
    'upgraded_consensus_state'?: ConsensusStateAssociatedWithTheRequestIdentifier;
}
/**
 * 
 * @export
 * @interface IbcCoreCommitmentV1MerklePrefix
 */
export interface IbcCoreCommitmentV1MerklePrefix {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreCommitmentV1MerklePrefix
     */
    'key_prefix'?: string;
}
/**
 * ConnectionEnd defines a stateful object on a chain connected to another separate one. NOTE: there must only be 2 defined ConnectionEnds to establish a connection between two chains.
 * @export
 * @interface IbcCoreConnectionV1ConnectionEnd
 */
export interface IbcCoreConnectionV1ConnectionEnd {
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    'client_id'?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for channels or packets utilising this connection.
     * @type {Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    'versions'?: Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    'state'?: IbcCoreConnectionV1ConnectionEndStateEnum;
    /**
     * 
     * @type {Connections200ResponseConnectionsInnerCounterparty}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    'counterparty'?: Connections200ResponseConnectionsInnerCounterparty;
    /**
     * delay period that must pass before a consensus state can be used for packet-verification NOTE: delay period logic is only implemented by some clients.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    'delay_period'?: string;
}

export const IbcCoreConnectionV1ConnectionEndStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN'
} as const;

export type IbcCoreConnectionV1ConnectionEndStateEnum = typeof IbcCoreConnectionV1ConnectionEndStateEnum[keyof typeof IbcCoreConnectionV1ConnectionEndStateEnum];

/**
 * Counterparty defines the counterparty chain associated with a connection end.
 * @export
 * @interface IbcCoreConnectionV1Counterparty
 */
export interface IbcCoreConnectionV1Counterparty {
    /**
     * identifies the client on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    'client_id'?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    'connection_id'?: string;
    /**
     * 
     * @type {MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    'prefix'?: MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey;
}
/**
 * IdentifiedConnection defines a connection with additional connection identifier field.
 * @export
 * @interface IbcCoreConnectionV1IdentifiedConnection
 */
export interface IbcCoreConnectionV1IdentifiedConnection {
    /**
     * connection identifier.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'id'?: string;
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'client_id'?: string;
    /**
     * 
     * @type {Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'versions'?: Array<IBCVersionWhichCanBeUtilisedToDetermineEncodingsOrProtocolsForChannelsOrPacketsUtilisingThisConnectionInner>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'state'?: IbcCoreConnectionV1IdentifiedConnectionStateEnum;
    /**
     * 
     * @type {Connections200ResponseConnectionsInnerCounterparty}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'counterparty'?: Connections200ResponseConnectionsInnerCounterparty;
    /**
     * delay period associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    'delay_period'?: string;
}

export const IbcCoreConnectionV1IdentifiedConnectionStateEnum = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN'
} as const;

export type IbcCoreConnectionV1IdentifiedConnectionStateEnum = typeof IbcCoreConnectionV1IdentifiedConnectionStateEnum[keyof typeof IbcCoreConnectionV1IdentifiedConnectionStateEnum];

/**
 * Params defines the set of Connection parameters.
 * @export
 * @interface IbcCoreConnectionV1Params
 */
export interface IbcCoreConnectionV1Params {
    /**
     * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the largest amount of time that the chain might reasonably take to produce the next block under normal operating conditions. A safe choice is 3-5x the expected time per block.
     * @type {string}
     * @memberof IbcCoreConnectionV1Params
     */
    'max_expected_time_per_block'?: string;
}
/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryClientConnectionsResponse
 */
export interface IbcCoreConnectionV1QueryClientConnectionsResponse {
    /**
     * slice of all the connection paths associated with a client.
     * @type {Array<string>}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    'connection_paths'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasGenerated}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasGenerated;
}
/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionClientStateResponse
 */
export interface IbcCoreConnectionV1QueryConnectionClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    'identified_client_state'?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionConsensusStateResponse
 */
export interface IbcCoreConnectionV1QueryConnectionConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionParamsResponse
 */
export interface IbcCoreConnectionV1QueryConnectionParamsResponse {
    /**
     * 
     * @type {ConnectionParams200ResponseParams}
     * @memberof IbcCoreConnectionV1QueryConnectionParamsResponse
     */
    'params'?: ConnectionParams200ResponseParams;
}
/**
 * QueryConnectionResponse is the response type for the Query/Connection RPC method. Besides the connection end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionResponse
 */
export interface IbcCoreConnectionV1QueryConnectionResponse {
    /**
     * 
     * @type {ConnectionAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    'connection'?: ConnectionAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryConnectionsResponse is the response type for the Query/Connections RPC method.
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionsResponse
 */
export interface IbcCoreConnectionV1QueryConnectionsResponse {
    /**
     * list of stored connections of the chain.
     * @type {Array<Connections200ResponseConnectionsInner>}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    'connections'?: Array<Connections200ResponseConnectionsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    'height'?: QueryBlockHeight;
}
/**
 * State defines if a connection is in one of the following states: INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A connection end has just started the opening handshake.  - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A connection end has completed the handshake.
 * @export
 * @enum {string}
 */

export const IbcCoreConnectionV1State = {
    UninitializedUnspecified: 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init: 'STATE_INIT',
    Tryopen: 'STATE_TRYOPEN',
    Open: 'STATE_OPEN'
} as const;

export type IbcCoreConnectionV1State = typeof IbcCoreConnectionV1State[keyof typeof IbcCoreConnectionV1State];


/**
 * Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.
 * @export
 * @interface IbcCoreConnectionV1Version
 */
export interface IbcCoreConnectionV1Version {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1Version
     */
    'identifier'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreConnectionV1Version
     */
    'features'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId
 */
export interface IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId {
    /**
     * 
     * @type {UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence}
     * @memberof IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId
     */
    'packet_id'?: UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence;
    /**
     * 
     * @type {Array<PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers>}
     * @memberof IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId
     */
    'packet_fees'?: Array<PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers>;
}
/**
 * QueryInterchainAccountResponse the response type for the Query/InterchainAccount RPC method.
 * @export
 * @interface InterchainAccount200Response
 */
export interface InterchainAccount200Response {
    /**
     * 
     * @type {string}
     * @memberof InterchainAccount200Response
     */
    'address'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InterchainAccountsControllerParams200Response
 */
export interface InterchainAccountsControllerParams200Response {
    /**
     * 
     * @type {InterchainAccountsControllerParams200ResponseParams}
     * @memberof InterchainAccountsControllerParams200Response
     */
    'params'?: InterchainAccountsControllerParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InterchainAccountsControllerParams200ResponseParams
 */
export interface InterchainAccountsControllerParams200ResponseParams {
    /**
     * controller_enabled enables or disables the controller submodule.
     * @type {boolean}
     * @memberof InterchainAccountsControllerParams200ResponseParams
     */
    'controller_enabled'?: boolean;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InterchainAccountsHostParams200Response
 */
export interface InterchainAccountsHostParams200Response {
    /**
     * 
     * @type {InterchainAccountsHostParams200ResponseParams}
     * @memberof InterchainAccountsHostParams200Response
     */
    'params'?: InterchainAccountsHostParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InterchainAccountsHostParams200ResponseParams
 */
export interface InterchainAccountsHostParams200ResponseParams {
    /**
     * host_enabled enables or disables the host submodule.
     * @type {boolean}
     * @memberof InterchainAccountsHostParams200ResponseParams
     */
    'host_enabled'?: boolean;
    /**
     * allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain.
     * @type {Array<string>}
     * @memberof InterchainAccountsHostParams200ResponseParams
     */
    'allow_messages'?: Array<string>;
}
/**
 * commitment merkle prefix of the counterparty chain.
 * @export
 * @interface MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey
 */
export interface MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey {
    /**
     * 
     * @type {string}
     * @memberof MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey
     */
    'key_prefix'?: string;
}
/**
 * 
 * @export
 * @interface PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers
 */
export interface PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers {
    /**
     * 
     * @type {FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket}
     * @memberof PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers
     */
    'fee'?: FeeEncapsulatesTheRecvAckAndTimeoutFeesAssociatedWithAnIBCPacket;
    /**
     * 
     * @type {string}
     * @memberof PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers
     */
    'refund_address'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PacketFeeContainsICS29RelayerFeesRefundAddressAndOptionalListOfPermittedRelayers
     */
    'relayers'?: Array<string>;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface PaginationResponse
 */
export interface PaginationResponse {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof PaginationResponse
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationResponse
     */
    'total'?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface QueryBlockHeight
 */
export interface QueryBlockHeight {
    /**
     * 
     * @type {string}
     * @memberof QueryBlockHeight
     */
    'revision_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryBlockHeight
     */
    'revision_height'?: string;
}
/**
 * 
 * @export
 * @interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
 */
export interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    'identified_client_state'?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
 */
export interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1 {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
 */
export interface QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod {
    /**
     * slice of all the connection paths associated with a client.
     * @type {Array<string>}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    'connection_paths'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasGenerated}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    'proof_height'?: HeightAtWhichTheProofWasGenerated;
}
/**
 * 
 * @export
 * @interface QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
 */
export interface QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod {
    /**
     * list of channels associated with a connection.
     * @type {Array<Channels200ResponseChannelsInner>}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    'channels'?: Array<Channels200ResponseChannelsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
 */
export interface QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    'identified_client_state'?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
 */
export interface QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod
 */
export interface QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod {
    /**
     * 
     * @type {Array<HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients>}
     * @memberof QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod
     */
    'consensus_state_heights'?: Array<HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
 */
export interface QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    'consensus_state'?: ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight;
    /**
     * 
     * @type {string}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    'proof_height'?: HeightIsAMonotonicallyIncreasingDataTypeThatCanBeComparedAgainstAnotherHeightForThePurposesOfUpdatingAndFreezingClients;
}
/**
 * 
 * @export
 * @interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
 */
export interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod {
    /**
     * 
     * @type {Array<ConsensusStatesAssociatedWithTheIdentifierInner>}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
     */
    'consensus_states'?: Array<ConsensusStatesAssociatedWithTheIdentifierInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc
 */
export interface QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc {
    /**
     * 
     * @type {string}
     * @memberof QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc
     */
    'counterparty_payee'?: string;
}
/**
 * 
 * @export
 * @interface QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc
 */
export interface QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc {
    /**
     * 
     * @type {boolean}
     * @memberof QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc
     */
    'fee_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc
 */
export interface QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc {
    /**
     * 
     * @type {Array<FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel>}
     * @memberof QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc
     */
    'fee_enabled_channels'?: Array<FeeEnabledChannelContainsThePortIDChannelIDForAFeeEnabledChannel>;
}
/**
 * 
 * @export
 * @interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc
 */
export interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc {
    /**
     * 
     * @type {IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId}
     * @memberof QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc
     */
    'incentivized_packet'?: IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId;
}
/**
 * 
 * @export
 * @interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC
 */
export interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC {
    /**
     * 
     * @type {Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>}
     * @memberof QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC
     */
    'incentivized_packets'?: Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>;
}
/**
 * 
 * @export
 * @interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc
 */
export interface QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc {
    /**
     * 
     * @type {Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>}
     * @memberof QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc
     */
    'incentivized_packets'?: Array<IdentifiedPacketFeesContainsAListOfTypePacketFeeAndAssociatedPacketId>;
}
/**
 * 
 * @export
 * @interface QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'acknowledgement'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
 */
export interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    'acknowledgements'?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    'height'?: QueryBlockHeight;
}
/**
 * PacketState defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @export
 * @interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner
 */
export interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner {
    /**
     * channel port identifier.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner
     */
    'port_id'?: string;
    /**
     * channel unique identifier.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner
     */
    'channel_id'?: string;
    /**
     * packet sequence.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner
     */
    'sequence'?: string;
    /**
     * embedded data that represents packet state.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'commitment'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
 */
export interface QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    'commitments'?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgementsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    'pagination'?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {boolean}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'received'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc
 */
export interface QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc {
    /**
     * 
     * @type {string}
     * @memberof QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc
     */
    'payee_address'?: string;
}
/**
 * 
 * @export
 * @interface QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
 */
export interface QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod {
    /**
     * 
     * @type {string}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    'next_sequence_receive'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    'proof'?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    'proof_height'?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc
 */
export interface QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc
     */
    'ack_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc
 */
export interface QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc
     */
    'recv_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc
 */
export interface QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc {
    /**
     * 
     * @type {Array<ThePacketReceiveFeeInner>}
     * @memberof QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc
     */
    'timeout_fees'?: Array<ThePacketReceiveFeeInner>;
}
/**
 * 
 * @export
 * @interface QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
 */
export interface QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
     */
    'sequences'?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
     */
    'height'?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
 */
export interface QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
     */
    'sequences'?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
     */
    'height'?: QueryBlockHeight;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface ThePacketReceiveFeeInner
 */
export interface ThePacketReceiveFeeInner {
    /**
     * 
     * @type {string}
     * @memberof ThePacketReceiveFeeInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThePacketReceiveFeeInner
     */
    'amount'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface TransferParams200Response
 */
export interface TransferParams200Response {
    /**
     * 
     * @type {TransferParams200ResponseParams}
     * @memberof TransferParams200Response
     */
    'params'?: TransferParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface TransferParams200ResponseParams
 */
export interface TransferParams200ResponseParams {
    /**
     * send_enabled enables or disables all cross-chain token transfers from this chain.
     * @type {boolean}
     * @memberof TransferParams200ResponseParams
     */
    'send_enabled'?: boolean;
    /**
     * receive_enabled enables or disables all cross-chain token transfers to this chain.
     * @type {boolean}
     * @memberof TransferParams200ResponseParams
     */
    'receive_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence
 */
export interface UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence {
    /**
     * 
     * @type {string}
     * @memberof UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence
     */
    'port_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniquePacketIdentifierComprisedOfTheChannelIDPortIDAndSequence
     */
    'sequence'?: string;
}
/**
 * QueryUpgradedClientStateResponse is the response type for the Query/UpgradedClientState RPC method.
 * @export
 * @interface UpgradedClientState200Response
 */
export interface UpgradedClientState200Response {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof UpgradedClientState200Response
     */
    'upgraded_client_state'?: ClientStateAssociatedWithTheRequestIdentifier;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface UpgradedConsensusState200Response
 */
export interface UpgradedConsensusState200Response {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheRequestIdentifier}
     * @memberof UpgradedConsensusState200Response
     */
    'upgraded_consensus_state'?: ConsensusStateAssociatedWithTheRequestIdentifier;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel: async (channelId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channel', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('channel', 'portId', portId)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelClientState: async (channelId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channelClientState', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('channelClientState', 'portId', portId)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelConsensusState: async (channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('channelConsensusState', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('channelConsensusState', 'portId', portId)
            // verify required parameter 'revisionNumber' is not null or undefined
            assertParamExists('channelConsensusState', 'revisionNumber', revisionNumber)
            // verify required parameter 'revisionHeight' is not null or undefined
            assertParamExists('channelConsensusState', 'revisionHeight', revisionHeight)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/channel/v1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConnections: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientConnections', 'clientId', clientId)
            const localVarPath = `/ibc/core/connection/v1/client_connections/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/client/v1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientState: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientState', 'clientId', clientId)
            const localVarPath = `/ibc/core/client/v1/client_states/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStates: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/client/v1/client_states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Status queries the status of an IBC client.
         * @param {string} clientId client unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStatus: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientStatus', 'clientId', clientId)
            const localVarPath = `/ibc/core/client/v1/client_status/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connection: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('connection', 'connectionId', connectionId)
            const localVarPath = `/ibc/core/connection/v1/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionChannels: async (connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connection' is not null or undefined
            assertParamExists('connectionChannels', 'connection', connection)
            const localVarPath = `/ibc/core/channel/v1/connections/{connection}/channels`
                .replace(`{${"connection"}}`, encodeURIComponent(String(connection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionClientState: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('connectionClientState', 'connectionId', connectionId)
            const localVarPath = `/ibc/core/connection/v1/connections/{connection_id}/client_state`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionConsensusState: async (connectionId: string, revisionNumber: string, revisionHeight: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('connectionConsensusState', 'connectionId', connectionId)
            // verify required parameter 'revisionNumber' is not null or undefined
            assertParamExists('connectionConsensusState', 'revisionNumber', revisionNumber)
            // verify required parameter 'revisionHeight' is not null or undefined
            assertParamExists('connectionConsensusState', 'revisionHeight', revisionHeight)
            const localVarPath = `/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionParams queries all parameters of the ibc connection submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/connection/v1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connections: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/connection/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusState: async (clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('consensusState', 'clientId', clientId)
            // verify required parameter 'revisionNumber' is not null or undefined
            assertParamExists('consensusState', 'revisionNumber', revisionNumber)
            // verify required parameter 'revisionHeight' is not null or undefined
            assertParamExists('consensusState', 'revisionHeight', revisionHeight)
            const localVarPath = `/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latestHeight !== undefined) {
                localVarQueryParameter['latest_height'] = latestHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConsensusStateHeights queries the height of every consensus states associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStateHeights: async (clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('consensusStateHeights', 'clientId', clientId)
            const localVarPath = `/ibc/core/client/v1/consensus_states/{client_id}/heights`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStates: async (clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('consensusStates', 'clientId', clientId)
            const localVarPath = `/ibc/core/client/v1/consensus_states/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CounterpartyPayee returns the registered counterparty payee for forward relaying
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the counterparty is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        counterpartyPayee: async (channelId: string, relayer: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('counterpartyPayee', 'channelId', channelId)
            // verify required parameter 'relayer' is not null or undefined
            assertParamExists('counterpartyPayee', 'relayer', relayer)
            const localVarPath = `/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"relayer"}}`, encodeURIComponent(String(relayer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomHash queries a denomination hash information.
         * @param {string} trace The denomination trace ([port_id]/[channel_id])+/[denom]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomHash: async (trace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trace' is not null or undefined
            assertParamExists('denomHash', 'trace', trace)
            const localVarPath = `/ibc/apps/transfer/v1/denom_hashes/{trace}`
                .replace(`{${"trace"}}`, encodeURIComponent(String(trace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTrace: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('denomTrace', 'hash', hash)
            const localVarPath = `/ibc/apps/transfer/v1/denom_traces/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTraces: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/transfer/v1/denom_traces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EscrowAddress returns the escrow address for a particular port and channel id.
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        escrowAddress: async (channelId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('escrowAddress', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('escrowAddress', 'portId', portId)
            const localVarPath = `/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEnabledChannel: async (channelId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('feeEnabledChannel', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('feeEnabledChannel', 'portId', portId)
            const localVarPath = `/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary FeeEnabledChannels returns a list of all fee enabled channels
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEnabledChannels: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/fee/v1/fee_enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }

            if (queryHeight !== undefined) {
                localVarQueryParameter['query_height'] = queryHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IncentivizedPacket returns all packet fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPacket: async (packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, queryHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packetIdChannelId' is not null or undefined
            assertParamExists('incentivizedPacket', 'packetIdChannelId', packetIdChannelId)
            // verify required parameter 'packetIdPortId' is not null or undefined
            assertParamExists('incentivizedPacket', 'packetIdPortId', packetIdPortId)
            // verify required parameter 'packetIdSequence' is not null or undefined
            assertParamExists('incentivizedPacket', 'packetIdSequence', packetIdSequence)
            const localVarPath = `/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/incentivized_packet`
                .replace(`{${"packet_id.channel_id"}}`, encodeURIComponent(String(packetIdChannelId)))
                .replace(`{${"packet_id.port_id"}}`, encodeURIComponent(String(packetIdPortId)))
                .replace(`{${"packet_id.sequence"}}`, encodeURIComponent(String(packetIdSequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queryHeight !== undefined) {
                localVarQueryParameter['query_height'] = queryHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IncentivizedPackets returns all incentivized packets and their associated fees
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPackets: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/fee/v1/incentivized_packets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }

            if (queryHeight !== undefined) {
                localVarQueryParameter['query_height'] = queryHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all incentivized packets for a specific channel
         * @param {string} channelId 
         * @param {string} portId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] Height to query at.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPacketsForChannel: async (channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('incentivizedPacketsForChannel', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('incentivizedPacketsForChannel', 'portId', portId)
            const localVarPath = `/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }

            if (queryHeight !== undefined) {
                localVarQueryParameter['query_height'] = queryHeight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary InterchainAccount returns the interchain account address for a given owner address on a given connection
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccount: async (owner: string, connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('interchainAccount', 'owner', owner)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('interchainAccount', 'connectionId', connectionId)
            const localVarPath = `/ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA controller submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccountsControllerParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/interchain_accounts/controller/v1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA host submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccountsHostParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/interchain_accounts/host/v1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextSequenceReceive: async (channelId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('nextSequenceReceive', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('nextSequenceReceive', 'portId', portId)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgement: async (channelId: string, portId: string, sequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('packetAcknowledgement', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('packetAcknowledgement', 'portId', portId)
            // verify required parameter 'sequence' is not null or undefined
            assertParamExists('packetAcknowledgement', 'sequence', sequence)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {Array<string>} [packetCommitmentSequences] list of packet sequences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgements: async (channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, packetCommitmentSequences?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('packetAcknowledgements', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('packetAcknowledgements', 'portId', portId)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }

            if (packetCommitmentSequences) {
                localVarQueryParameter['packet_commitment_sequences'] = packetCommitmentSequences;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitment: async (channelId: string, portId: string, sequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('packetCommitment', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('packetCommitment', 'portId', portId)
            // verify required parameter 'sequence' is not null or undefined
            assertParamExists('packetCommitment', 'sequence', sequence)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitments: async (channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('packetCommitments', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('packetCommitments', 'portId', portId)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetReceipt: async (channelId: string, portId: string, sequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('packetReceipt', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('packetReceipt', 'portId', portId)
            // verify required parameter 'sequence' is not null or undefined
            assertParamExists('packetReceipt', 'sequence', sequence)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Payee returns the registered payee address for a specific channel given the relayer address
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the distribution address is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payee: async (channelId: string, relayer: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('payee', 'channelId', channelId)
            // verify required parameter 'relayer' is not null or undefined
            assertParamExists('payee', 'relayer', relayer)
            const localVarPath = `/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"relayer"}}`, encodeURIComponent(String(relayer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TotalAckFees returns the total acknowledgement fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalAckFees: async (packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packetIdChannelId' is not null or undefined
            assertParamExists('totalAckFees', 'packetIdChannelId', packetIdChannelId)
            // verify required parameter 'packetIdPortId' is not null or undefined
            assertParamExists('totalAckFees', 'packetIdPortId', packetIdPortId)
            // verify required parameter 'packetIdSequence' is not null or undefined
            assertParamExists('totalAckFees', 'packetIdSequence', packetIdSequence)
            const localVarPath = `/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_ack_fees`
                .replace(`{${"packet_id.channel_id"}}`, encodeURIComponent(String(packetIdChannelId)))
                .replace(`{${"packet_id.port_id"}}`, encodeURIComponent(String(packetIdPortId)))
                .replace(`{${"packet_id.sequence"}}`, encodeURIComponent(String(packetIdSequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TotalRecvFees returns the total receive fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRecvFees: async (packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packetIdChannelId' is not null or undefined
            assertParamExists('totalRecvFees', 'packetIdChannelId', packetIdChannelId)
            // verify required parameter 'packetIdPortId' is not null or undefined
            assertParamExists('totalRecvFees', 'packetIdPortId', packetIdPortId)
            // verify required parameter 'packetIdSequence' is not null or undefined
            assertParamExists('totalRecvFees', 'packetIdSequence', packetIdSequence)
            const localVarPath = `/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_recv_fees`
                .replace(`{${"packet_id.channel_id"}}`, encodeURIComponent(String(packetIdChannelId)))
                .replace(`{${"packet_id.port_id"}}`, encodeURIComponent(String(packetIdPortId)))
                .replace(`{${"packet_id.sequence"}}`, encodeURIComponent(String(packetIdSequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TotalTimeoutFees returns the total timeout fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalTimeoutFees: async (packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packetIdChannelId' is not null or undefined
            assertParamExists('totalTimeoutFees', 'packetIdChannelId', packetIdChannelId)
            // verify required parameter 'packetIdPortId' is not null or undefined
            assertParamExists('totalTimeoutFees', 'packetIdPortId', packetIdPortId)
            // verify required parameter 'packetIdSequence' is not null or undefined
            assertParamExists('totalTimeoutFees', 'packetIdSequence', packetIdSequence)
            const localVarPath = `/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_timeout_fees`
                .replace(`{${"packet_id.channel_id"}}`, encodeURIComponent(String(packetIdChannelId)))
                .replace(`{${"packet_id.port_id"}}`, encodeURIComponent(String(packetIdPortId)))
                .replace(`{${"packet_id.sequence"}}`, encodeURIComponent(String(packetIdSequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/apps/transfer/v1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedAcks: async (channelId: string, portId: string, packetAckSequences: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('unreceivedAcks', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('unreceivedAcks', 'portId', portId)
            // verify required parameter 'packetAckSequences' is not null or undefined
            assertParamExists('unreceivedAcks', 'packetAckSequences', packetAckSequences)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"packet_ack_sequences"}}`, encodeURIComponent(String(packetAckSequences)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedPackets: async (channelId: string, portId: string, packetCommitmentSequences: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('unreceivedPackets', 'channelId', channelId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('unreceivedPackets', 'portId', portId)
            // verify required parameter 'packetCommitmentSequences' is not null or undefined
            assertParamExists('unreceivedPackets', 'packetCommitmentSequences', packetCommitmentSequences)
            const localVarPath = `/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"packet_commitment_sequences"}}`, encodeURIComponent(String(packetCommitmentSequences)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UpgradedClientState queries an Upgraded IBC light client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedClientState: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/client/v1/upgraded_client_states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UpgradedConsensusState queries an Upgraded IBC consensus state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/client/v1/upgraded_consensus_states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channel(channelId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channel(channelId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelClientState(channelId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelClientState(channelId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channels200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientConnections(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientConnections(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientState(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientState(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientStates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Status queries the status of an IBC client.
         * @param {string} clientId client unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientStatus(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientStatus(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connection(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connection(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionClientState(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectionClientState(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectionConsensusState(connectionId, revisionNumber, revisionHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConnectionParams queries all parameters of the ibc connection submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectionParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConsensusStateHeights queries the height of every consensus states associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consensusStateHeights(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consensusStateHeights(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary CounterpartyPayee returns the registered counterparty payee for forward relaying
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the counterparty is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async counterpartyPayee(channelId: string, relayer: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.counterpartyPayee(channelId, relayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DenomHash queries a denomination hash information.
         * @param {string} trace The denomination trace ([port_id]/[channel_id])+/[denom]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomHash(trace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomHash200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomHash(trace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomTrace(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomTrace200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomTrace(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomTraces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary EscrowAddress returns the escrow address for a particular port and channel id.
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async escrowAddress(channelId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EscrowAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.escrowAddress(channelId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feeEnabledChannel(channelId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feeEnabledChannel(channelId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary FeeEnabledChannels returns a list of all fee enabled channels
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feeEnabledChannels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feeEnabledChannels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IncentivizedPacket returns all packet fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incentivizedPacket(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, queryHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incentivizedPacket(packetIdChannelId, packetIdPortId, packetIdSequence, queryHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IncentivizedPackets returns all incentivized packets and their associated fees
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incentivizedPackets(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incentivizedPackets(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all incentivized packets for a specific channel
         * @param {string} channelId 
         * @param {string} portId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] Height to query at.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incentivizedPacketsForChannel(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incentivizedPacketsForChannel(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary InterchainAccount returns the interchain account address for a given owner address on a given connection
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interchainAccount(owner: string, connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterchainAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interchainAccount(owner, connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA controller submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interchainAccountsControllerParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterchainAccountsControllerParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interchainAccountsControllerParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA host submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interchainAccountsHostParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterchainAccountsHostParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interchainAccountsHostParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nextSequenceReceive(channelId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nextSequenceReceive(channelId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packetAcknowledgement(channelId, portId, sequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {Array<string>} [packetCommitmentSequences] list of packet sequences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, packetCommitmentSequences?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, packetCommitmentSequences, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetCommitment(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packetCommitment(channelId, portId, sequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetReceipt(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packetReceipt(channelId, portId, sequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Payee returns the registered payee address for a specific channel given the relayer address
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the distribution address is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payee(channelId: string, relayer: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payee(channelId, relayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TotalAckFees returns the total acknowledgement fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalAckFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totalAckFees(packetIdChannelId, packetIdPortId, packetIdSequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TotalRecvFees returns the total receive fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalRecvFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totalRecvFees(packetIdChannelId, packetIdPortId, packetIdSequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TotalTimeoutFees returns the total timeout fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalTimeoutFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totalTimeoutFees(packetIdChannelId, packetIdPortId, packetIdSequence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unreceivedAcks(channelId, portId, packetAckSequences, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unreceivedPackets(channelId, portId, packetCommitmentSequences, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UpgradedClientState queries an Upgraded IBC light client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradedClientState(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradedClientState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradedClientState(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UpgradedConsensusState queries an Upgraded IBC consensus state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradedConsensusState(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradedConsensusState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradedConsensusState(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel(channelId: string, portId: string, options?: any): AxiosPromise<Channel200Response> {
            return localVarFp.channel(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelClientState(channelId: string, portId: string, options?: any): AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod> {
            return localVarFp.channelClientState(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: any): AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1> {
            return localVarFp.channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Channels200Response> {
            return localVarFp.channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConnections(clientId: string, options?: any): AxiosPromise<QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod> {
            return localVarFp.clientConnections(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientParams(options?: any): AxiosPromise<ClientParams200Response> {
            return localVarFp.clientParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientState(clientId: string, options?: any): AxiosPromise<ClientState200Response> {
            return localVarFp.clientState(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<ClientStates200Response> {
            return localVarFp.clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Status queries the status of an IBC client.
         * @param {string} clientId client unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStatus(clientId: string, options?: any): AxiosPromise<ClientStatus200Response> {
            return localVarFp.clientStatus(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connection(connectionId: string, options?: any): AxiosPromise<Connection200Response> {
            return localVarFp.connection(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod> {
            return localVarFp.connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionClientState(connectionId: string, options?: any): AxiosPromise<QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod> {
            return localVarFp.connectionClientState(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: any): AxiosPromise<QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod> {
            return localVarFp.connectionConsensusState(connectionId, revisionNumber, revisionHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionParams queries all parameters of the ibc connection submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionParams(options?: any): AxiosPromise<ConnectionParams200Response> {
            return localVarFp.connectionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Connections200Response> {
            return localVarFp.connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: any): AxiosPromise<QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod> {
            return localVarFp.consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConsensusStateHeights queries the height of every consensus states associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStateHeights(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryConsensusStateHeightsResponseIsTheResponseTypeForTheQueryConsensusStateHeightsRPCMethod> {
            return localVarFp.consensusStateHeights(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod> {
            return localVarFp.consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CounterpartyPayee returns the registered counterparty payee for forward relaying
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the counterparty is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        counterpartyPayee(channelId: string, relayer: string, options?: any): AxiosPromise<QueryCounterpartyPayeeResponseDefinesTheResponseTypeForTheCounterpartyPayeeRpc> {
            return localVarFp.counterpartyPayee(channelId, relayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomHash queries a denomination hash information.
         * @param {string} trace The denomination trace ([port_id]/[channel_id])+/[denom]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomHash(trace: string, options?: any): AxiosPromise<DenomHash200Response> {
            return localVarFp.denomHash(trace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTrace(hash: string, options?: any): AxiosPromise<DenomTrace200Response> {
            return localVarFp.denomTrace(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<DenomTraces200Response> {
            return localVarFp.denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary EscrowAddress returns the escrow address for a particular port and channel id.
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        escrowAddress(channelId: string, portId: string, options?: any): AxiosPromise<EscrowAddress200Response> {
            return localVarFp.escrowAddress(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel
         * @param {string} channelId unique channel identifier
         * @param {string} portId unique port identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEnabledChannel(channelId: string, portId: string, options?: any): AxiosPromise<QueryFeeEnabledChannelResponseDefinesTheResponseTypeForTheFeeEnabledChannelRpc> {
            return localVarFp.feeEnabledChannel(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary FeeEnabledChannels returns a list of all fee enabled channels
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feeEnabledChannels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: any): AxiosPromise<QueryFeeEnabledChannelsResponseDefinesTheResponseTypeForTheFeeEnabledChannelsRpc> {
            return localVarFp.feeEnabledChannels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IncentivizedPacket returns all packet fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPacket(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, queryHeight?: string, options?: any): AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketRpc> {
            return localVarFp.incentivizedPacket(packetIdChannelId, packetIdPortId, packetIdSequence, queryHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IncentivizedPackets returns all incentivized packets and their associated fees
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] block height at which to query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPackets(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: any): AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRpc> {
            return localVarFp.incentivizedPackets(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all incentivized packets for a specific channel
         * @param {string} channelId 
         * @param {string} portId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {string} [queryHeight] Height to query at.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentivizedPacketsForChannel(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: any): AxiosPromise<QueryIncentivizedPacketsResponseDefinesTheResponseTypeForTheIncentivizedPacketsRPC> {
            return localVarFp.incentivizedPacketsForChannel(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary InterchainAccount returns the interchain account address for a given owner address on a given connection
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccount(owner: string, connectionId: string, options?: any): AxiosPromise<InterchainAccount200Response> {
            return localVarFp.interchainAccount(owner, connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA controller submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccountsControllerParams(options?: any): AxiosPromise<InterchainAccountsControllerParams200Response> {
            return localVarFp.interchainAccountsControllerParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the ICA host submodule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interchainAccountsHostParams(options?: any): AxiosPromise<InterchainAccountsHostParams200Response> {
            return localVarFp.interchainAccountsHostParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextSequenceReceive(channelId: string, portId: string, options?: any): AxiosPromise<QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod> {
            return localVarFp.nextSequenceReceive(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return localVarFp.packetAcknowledgement(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {Array<string>} [packetCommitmentSequences] list of packet sequences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, packetCommitmentSequences?: Array<string>, options?: any): AxiosPromise<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod> {
            return localVarFp.packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, packetCommitmentSequences, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitment(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return localVarFp.packetCommitment(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod> {
            return localVarFp.packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetReceipt(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return localVarFp.packetReceipt(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Payee returns the registered payee address for a specific channel given the relayer address
         * @param {string} channelId unique channel identifier
         * @param {string} relayer the relayer address to which the distribution address is registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payee(channelId: string, relayer: string, options?: any): AxiosPromise<QueryPayeeResponseDefinesTheResponseTypeForThePayeeRpc> {
            return localVarFp.payee(channelId, relayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TotalAckFees returns the total acknowledgement fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalAckFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: any): AxiosPromise<QueryTotalAckFeesResponseDefinesTheResponseTypeForTheTotalAckFeesRpc> {
            return localVarFp.totalAckFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TotalRecvFees returns the total receive fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRecvFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: any): AxiosPromise<QueryTotalRecvFeesResponseDefinesTheResponseTypeForTheTotalRecvFeesRpc> {
            return localVarFp.totalRecvFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TotalTimeoutFees returns the total timeout fees for a packet given its identifier
         * @param {string} packetIdChannelId channel unique identifier
         * @param {string} packetIdPortId channel port identifier
         * @param {string} packetIdSequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalTimeoutFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: any): AxiosPromise<QueryTotalTimeoutFeesResponseDefinesTheResponseTypeForTheTotalTimeoutFeesRpc> {
            return localVarFp.totalTimeoutFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferParams(options?: any): AxiosPromise<TransferParams200Response> {
            return localVarFp.transferParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: any): AxiosPromise<QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod> {
            return localVarFp.unreceivedAcks(channelId, portId, packetAckSequences, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: any): AxiosPromise<QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod> {
            return localVarFp.unreceivedPackets(channelId, portId, packetCommitmentSequences, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UpgradedClientState queries an Upgraded IBC light client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedClientState(options?: any): AxiosPromise<UpgradedClientState200Response> {
            return localVarFp.upgradedClientState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UpgradedConsensusState queries an Upgraded IBC consensus state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState(options?: any): AxiosPromise<UpgradedConsensusState200Response> {
            return localVarFp.upgradedConsensusState(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Channel queries an IBC Channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channel(channelId: string, portId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).channel(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channelClientState(channelId: string, portId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).channelClientState(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} revisionNumber revision number of the consensus state
     * @param {string} revisionHeight revision height of the consensus state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Channels queries all the IBC channels of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientConnections queries the connection paths associated with a client state.
     * @param {string} clientId client identifier associated with a connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientConnections(clientId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).clientConnections(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientParams queries all parameters of the ibc client submodule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).clientParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientState queries an IBC light client.
     * @param {string} clientId client state unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientState(clientId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).clientState(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientStates queries all the IBC light clients of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Status queries the status of an IBC client.
     * @param {string} clientId client unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientStatus(clientId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).clientStatus(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connection queries an IBC connection end.
     * @param {string} connectionId connection unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connection(connectionId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connection(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionChannels queries all the channels associated with a connection end.
     * @param {string} connection connection unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionClientState queries the client state associated with the connection.
     * @param {string} connectionId connection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionClientState(connectionId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connectionClientState(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionConsensusState queries the consensus state associated with the connection.
     * @param {string} connectionId connection identifier
     * @param {string} revisionNumber 
     * @param {string} revisionHeight 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connectionConsensusState(connectionId, revisionNumber, revisionHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionParams queries all parameters of the ibc connection submodule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connectionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connections queries all the IBC connections of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConsensusState queries a consensus state associated with a client state at a given height.
     * @param {string} clientId client identifier
     * @param {string} revisionNumber consensus state revision number
     * @param {string} revisionHeight consensus state revision height
     * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConsensusStateHeights queries the height of every consensus states associated with a given client.
     * @param {string} clientId client identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public consensusStateHeights(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).consensusStateHeights(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConsensusStates queries all the consensus state associated with a given client.
     * @param {string} clientId client identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CounterpartyPayee returns the registered counterparty payee for forward relaying
     * @param {string} channelId unique channel identifier
     * @param {string} relayer the relayer address to which the counterparty is registered
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public counterpartyPayee(channelId: string, relayer: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).counterpartyPayee(channelId, relayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomHash queries a denomination hash information.
     * @param {string} trace The denomination trace ([port_id]/[channel_id])+/[denom]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomHash(trace: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomHash(trace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomTrace queries a denomination trace information.
     * @param {string} hash hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomTrace(hash: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomTrace(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomTraces queries all denomination traces.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary EscrowAddress returns the escrow address for a particular port and channel id.
     * @param {string} channelId unique channel identifier
     * @param {string} portId unique port identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public escrowAddress(channelId: string, portId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).escrowAddress(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel
     * @param {string} channelId unique channel identifier
     * @param {string} portId unique port identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public feeEnabledChannel(channelId: string, portId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).feeEnabledChannel(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary FeeEnabledChannels returns a list of all fee enabled channels
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {string} [queryHeight] block height at which to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public feeEnabledChannels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).feeEnabledChannels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IncentivizedPacket returns all packet fees for a packet given its identifier
     * @param {string} packetIdChannelId channel unique identifier
     * @param {string} packetIdPortId channel port identifier
     * @param {string} packetIdSequence packet sequence
     * @param {string} [queryHeight] block height at which to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public incentivizedPacket(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, queryHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).incentivizedPacket(packetIdChannelId, packetIdPortId, packetIdSequence, queryHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IncentivizedPackets returns all incentivized packets and their associated fees
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {string} [queryHeight] block height at which to query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public incentivizedPackets(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).incentivizedPackets(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all incentivized packets for a specific channel
     * @param {string} channelId 
     * @param {string} portId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {string} [queryHeight] Height to query at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public incentivizedPacketsForChannel(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, queryHeight?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).incentivizedPacketsForChannel(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, queryHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary InterchainAccount returns the interchain account address for a given owner address on a given connection
     * @param {string} owner 
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public interchainAccount(owner: string, connectionId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).interchainAccount(owner, connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the ICA controller submodule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public interchainAccountsControllerParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).interchainAccountsControllerParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the ICA host submodule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public interchainAccountsHostParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).interchainAccountsHostParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NextSequenceReceive returns the next receive sequence for a given channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nextSequenceReceive(channelId: string, portId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nextSequenceReceive(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).packetAcknowledgement(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {Array<string>} [packetCommitmentSequences] list of packet sequences.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, packetCommitmentSequences?: Array<string>, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, packetCommitmentSequences, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketCommitment queries a stored packet commitment hash.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetCommitment(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).packetCommitment(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetReceipt(channelId: string, portId: string, sequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).packetReceipt(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Payee returns the registered payee address for a specific channel given the relayer address
     * @param {string} channelId unique channel identifier
     * @param {string} relayer the relayer address to which the distribution address is registered
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public payee(channelId: string, relayer: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).payee(channelId, relayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TotalAckFees returns the total acknowledgement fees for a packet given its identifier
     * @param {string} packetIdChannelId channel unique identifier
     * @param {string} packetIdPortId channel port identifier
     * @param {string} packetIdSequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public totalAckFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).totalAckFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TotalRecvFees returns the total receive fees for a packet given its identifier
     * @param {string} packetIdChannelId channel unique identifier
     * @param {string} packetIdPortId channel port identifier
     * @param {string} packetIdSequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public totalRecvFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).totalRecvFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TotalTimeoutFees returns the total timeout fees for a packet given its identifier
     * @param {string} packetIdChannelId channel unique identifier
     * @param {string} packetIdPortId channel port identifier
     * @param {string} packetIdSequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public totalTimeoutFees(packetIdChannelId: string, packetIdPortId: string, packetIdSequence: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).totalTimeoutFees(packetIdChannelId, packetIdPortId, packetIdSequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the ibc-transfer module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public transferParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).transferParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {Array<string>} packetAckSequences list of acknowledgement sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).unreceivedAcks(channelId, portId, packetAckSequences, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {Array<string>} packetCommitmentSequences list of packet sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).unreceivedPackets(channelId, portId, packetCommitmentSequences, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UpgradedClientState queries an Upgraded IBC light client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public upgradedClientState(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).upgradedClientState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UpgradedConsensusState queries an Upgraded IBC consensus state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public upgradedConsensusState(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).upgradedConsensusState(options).then((request) => request(this.axios, this.basePath));
    }
}



